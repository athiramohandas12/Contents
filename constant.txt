# -*- coding: utf-8 -*-
"""DIP_Lab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NxukCjO-mUasaV8dFutra8R_sya7e5t2

Implement the image negative transformation function and apply it to a grayscale image.
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def apply_negative_transformation(image):
    """
    Apply the image negative transformation to a grayscale image.

    Parameters:
        image (numpy.ndarray): Input grayscale image.

    Returns:
        numpy.ndarray: Image after applying negative transformation.
    """
    if len(image.shape) != 2:
        raise ValueError("Input image must be grayscale.")

    # Perform negative transformation: new_pixel = 255 - old_pixel
    negative_image = 255 - image

    return negative_image

def main():
    # Load the grayscale image
    image_path = '/content/56368408-58561980-61c5-11e9-9800-0678dc02b4e7.png'  # Replace with your image path
    grayscale_image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    if grayscale_image is None:
        raise FileNotFoundError("Image file not found. Check the path.")

    # Apply the negative transformation
    negative_image = apply_negative_transformation(grayscale_image)

    # Display the original and negative images
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.title("Original Image")
    plt.imshow(grayscale_image, cmap='gray')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.title("Negative Image")
    plt.imshow(negative_image, cmap='gray')
    plt.axis('off')

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()

"""Analyze the effect of image negative on different types of images (e.g., low contrast, high
contrast).
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Function to compute image negative
def image_negative(image):
    return 255 - image

# Function to display images side by side
def display_images(original, transformed, title1="Original", title2="Transformed"):
    plt.figure(figsize=(10, 5))

    # Original image
    plt.subplot(1, 2, 1)
    plt.imshow(original, cmap='gray')
    plt.title(title1)
    plt.axis('off')

    # Transformed image
    plt.subplot(1, 2, 2)
    plt.imshow(transformed, cmap='gray')
    plt.title(title2)
    plt.axis('off')

    plt.tight_layout()
    plt.show()

# Load sample images

low_contrast_image = cv2.imread('/content/p3292964492-5-533x800.jpg', cv2.IMREAD_GRAYSCALE)
high_contrast_image = cv2.imread('/content/1000304.jpg', cv2.IMREAD_GRAYSCALE)

if low_contrast_image is None or high_contrast_image is None:
    print("Please ensure the image files are available in the specified paths.")
else:
    # Apply image negative transformation
    low_contrast_negative = image_negative(low_contrast_image)
    high_contrast_negative = image_negative(high_contrast_image)

    # Display results
    print("Low Contrast Image Analysis")
    display_images(low_contrast_image, low_contrast_negative, "Low Contrast", "Negative")

    print("High Contrast Image Analysis")
    display_images(high_contrast_image, high_contrast_negative, "High Contrast", "Negative")

"""Compare the histogram of an original image with its negative. Explain the observed
differences.
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

12341# Load a grayscale image
image = cv2.imread('/content/56368408-58561980-61c5-11e9-9800-0678dc02b4e7.png', cv2.IMREAD_GRAYSCALE)

# Create the negative of the image
negative_image = 255 - image

# Calculate histograms for the original and negative images
original_hist = cv2.calcHist([image], [0], None, [256], [0, 256])
negative_hist = cv2.calcHist([negative_image], [0], None, [256], [0, 256])

# Normalize histograms for better comparison
original_hist /= original_hist.sum()
negative_hist /= negative_hist.sum()

# Plot the histograms
plt.figure(figsize=(12, 6))

# Original Image Histogram
plt.subplot(1, 2, 1)
plt.title("Original Image Histogram")
plt.xlabel("Pixel Intensity")
plt.ylabel("Frequency")
plt.plot(original_hist, color='blue')
plt.grid()

# Negative Image Histogram
plt.subplot(1, 2, 2)
plt.title("Negative Image Histogram")
plt.xlabel("Pixel Intensity")
plt.ylabel("Frequency")
plt.plot(negative_hist, color='red')
plt.grid()

# Show the plots
plt.tight_layout()
plt.show()

"""Implement the log transformation function and apply it to an image with a narrow range of
low gray-level values.
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def log_transform(image):
    """
    Apply log transformation to an image.

    Parameters:
        image (numpy.ndarray): Input image.

    Returns:
        numpy.ndarray: Log-transformed image.
    """
    # Convert the image to float32 for precision in log transformation
    image_float = image.astype(np.float32)

    # Apply log transformation
    c = 255 / (np.log(1 + np.max(image_float)))  # Scaling constant
    log_image = c * np.log(1 + image_float)

    # Convert back to uint8
    log_image = np.uint8(log_image)

    return log_image

# Load an image with a narrow range of low gray-level values
# You can replace 'low_gray_image.jpg' with the path to your image
image_path = "/content/mage-Suffering-from-Un-even-illumination-Grey-Level-Image-size-512x512.png"
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

if image is None:
    raise FileNotFoundError(f"Image not found at {image_path}")

# Apply the log transformation
log_image = log_transform(image)

# Display the original and log-transformed images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.title("Original Image")
plt.imshow(image, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title("Log-Transformed Image")
plt.imshow(log_image, cmap='gray')
plt.axis('off')

plt.tight_layout()
plt.show()

# Save the log-transformed image (optional)
cv2.imwrite("log_transformed_image.jpg", log_image)

import cv2
import numpy as np
import matplotlib.pyplot as plt

def log_transform(image):
    """
    Apply log transformation to an image.

    Parameters:
        image (numpy.ndarray): Input image.

    Returns:
        numpy.ndarray: Log-transformed image.
    """
    # Convert the image to float32 for precision in log transformation
    image_float = image.astype(np.float32)

    # Apply log transformation
    c = 255 / (np.log(1 + np.max(image_float)))  # Scaling constant
    log_image = c * np.log(1 + image_float)

    # Convert back to uint8
    log_image = np.uint8(log_image)

    return log_image

# Load an image with a narrow range of low gray-level values
# You can replace 'low_gray_image.jpg' with the path to your image
image_path = "/content/einstein.jpg"
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

if image is None:
    raise FileNotFoundError(f"Image not found at {image_path}")

# Apply the log transformation
log_image = log_transform(image)

# Display the original and log-transformed images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.title("Original Image")
plt.imshow(image, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title("Log-Transformed Image")
plt.imshow(log_image, cmap='gray')
plt.axis('off')

plt.tight_layout()
plt.show()

# Save the log-transformed image (optional)
cv2.imwrite("log_transformed_image.jpg", log_image)

"""Analyze the effect of the log transformation on enhancing details in dark regions of an image."""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def log_transform(image):
    """
    Apply log transformation to an image.

    Parameters:
        image (numpy.ndarray): Input image.

    Returns:
        numpy.ndarray: Log-transformed image.
    """
    # Convert the image to float32 for precision in log transformation
    image_float = image.astype(np.float32)

    # Apply log transformation
    c = 255 / (np.log(1 + np.max(image_float)))  # Scaling constant
    log_image = c * np.log(1 + image_float)

    # Convert back to uint8
    log_image = np.uint8(log_image)

    return log_image

# Analyze the effect of the log transformation

def analyze_log_transformation(original_image, transformed_image):
    """
    Analyze the effect of log transformation on enhancing details in dark regions.

    Parameters:
        original_image (numpy.ndarray): Original input image.
        transformed_image (numpy.ndarray): Log-transformed image.
    """
    # Compute histograms
    original_hist = cv2.calcHist([original_image], [0], None, [256], [0, 256])
    transformed_hist = cv2.calcHist([transformed_image], [0], None, [256], [0, 256])

    # Plot histograms and images
    plt.figure(figsize=(12, 8))

    # Original image and its histogram
    plt.subplot(2, 2, 1)
    plt.title("Original Image")
    plt.imshow(original_image, cmap='gray')
    plt.axis('off')

    plt.subplot(2, 2, 2)
    plt.title("Histogram of Original Image")
    plt.plot(original_hist, color='blue')
    plt.xlim([0, 256])

    # Log-transformed image and its histogram
    plt.subplot(2, 2, 3)
    plt.title("Log-Transformed Image")
    plt.imshow(transformed_image, cmap='gray')
    plt.axis('off')

    plt.subplot(2, 2, 4)
    plt.title("Histogram of Log-Transformed Image")
    plt.plot(transformed_hist, color='green')
    plt.xlim([0, 256])

    plt.tight_layout()
    plt.show()

# Load an image with a narrow range of low gray-level values
# You can replace 'low_gray_image.jpg' with the path to your image
image_path = "/content/einstein.jpg"
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

if image is None:
    raise FileNotFoundError(f"Image not found at {image_path}")

# Apply the log transformation
log_image = log_transform(image)

# Display the original and log-transformed images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.title("Original Image")
plt.imshow(image, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title("Log-Transformed Image")
plt.imshow(log_image, cmap='gray')
plt.axis('off')

plt.tight_layout()
plt.show()

# Analyze the effect
analyze_log_transformation(image, log_image)

# Save the log-transformed image (optional)
cv2.imwrite("log_transformed_image.jpg", log_image)

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image = cv2.imread('/content/images (7).jpeg', cv2.IMREAD_GRAYSCALE)

# Apply log transformation
c = 255 / np.log(1 + np.max(image))  # Scaling constant
log_transformed = c * np.log(1 + image.astype(np.float32))

# Normalize the log-transformed image
log_transformed = np.uint8(cv2.normalize(log_transformed, None, 0, 255, cv2.NORM_MINMAX))

# Plot the original and transformed images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.title("Original Image")
plt.imshow(image, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title("Log Transformed Image")
plt.imshow(log_transformed, cmap='gray')
plt.axis('off')

plt.tight_layout()
plt.show()

"""Experiment with different values of the constant 'c' in the log transformation equation and
observe the changes in output image.
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def log_transformation(image, c):
    """
    Apply log transformation to an image.

    Parameters:
        image (numpy.ndarray): Input grayscale image.
        c (float): Constant for log transformation.

    Returns:
        numpy.ndarray: Log-transformed image.
    """
    # Ensure the input image is in float format for log transformation
    image = image.astype(np.float32)

    # Apply the log transformation equation
    log_image = c * np.log1p(image)

    # Normalize to the range [0, 255] for visualization
    log_image = cv2.normalize(log_image, None, 0, 255, cv2.NORM_MINMAX)
    log_image = np.uint8(log_image)

    return log_image

def display_images(images, titles, rows, cols):
    """
    Display multiple images in a grid.

    Parameters:
        images (list of numpy.ndarray): List of images to display.
        titles (list of str): List of titles for the images.
        rows (int): Number of rows in the grid.
        cols (int): Number of columns in the grid.
    """
    plt.figure(figsize=(15, 10))
    for i, (image, title) in enumerate(zip(images, titles)):
        plt.subplot(rows, cols, i + 1)
        plt.imshow(image, cmap='gray')
        plt.title(title)
        plt.axis('off')
    plt.tight_layout()
    plt.show()

# Load the input image
image_path = "/content/56368408-58561980-61c5-11e9-9800-0678dc02b4e7.png"  # Replace with your image path
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

if image is None:
    raise ValueError("Image not found at the specified path.")

# Define different values of c to experiment with
c_values = [1, 5, 10, 20]

# Apply log transformation for each value of c and store the results
images = [image]
titles = ["Original Image"]

for c in c_values:
    transformed_image = log_transformation(image, c)
    images.append(transformed_image)
    titles.append(f"Log Transform (c = {c})")

# Display the images
display_images(images, titles, rows=1, cols=len(images))

"""Implement the power-law transformation function with different values of gamma."""

import numpy as np
import matplotlib.pyplot as plt

def power_law_transformation(image, gamma):
    """
    Apply power-law (gamma) transformation to an image.

    Parameters:
        image (ndarray): Input image (can be grayscale or color).
        gamma (float): Gamma value for the transformation.

    Returns:
        transformed_image (ndarray): Gamma-transformed image.
    """
    # Normalize the image to the range [0, 1]
    image_normalized = image / 255.0

    # Apply the power-law transformation
    transformed_image = np.power(image_normalized, gamma)

    # Rescale to [0, 255] and convert back to uint8
    transformed_image = np.uint8(transformed_image * 255)

    return transformed_image

# Example usage
if __name__ == "__main__":
    # Load an example image (you can replace this with your image path)

    image = plt.imread('/content/einstein.jpg')

    # Test with different gamma values
    gamma_values = [0.5, 1.0, 2.0]

    plt.figure(figsize=(12, 4))

    for i, gamma in enumerate(gamma_values):
        transformed_image = power_law_transformation(image, gamma)
        plt.subplot(1, len(gamma_values), i+1)
        plt.imshow(transformed_image)
        plt.title(f'Gamma = {gamma}')
        plt.axis('off')

    plt.show()

"""Apply the power-law transformation to enhance images with different contrast characteristics."""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def power_law_transformation(image, gamma):
    # Normalize the image to the range [0, 1]
    normalized_image = image / 255.0

    # Apply the power-law transformation
    transformed_image = np.power(normalized_image, gamma)

    # Convert back to the range [0, 255]
    transformed_image = np.uint8(transformed_image * 255)

    return transformed_image

# Read an image
image_path = '/content/einstein.jpg'  # Replace with your image path
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)  # Load the image in grayscale

# Apply the power-law transformation with a gamma value
gamma = 2.0  # You can adjust this value
transformed_image = power_law_transformation(image, gamma)

# Display the original and transformed images side by side
plt.figure(figsize=(10, 5))

# Original Image
plt.subplot(1, 2, 1)
plt.imshow(image, cmap='gray')
plt.title('Original Image')
plt.axis('off')

# Transformed Image
plt.subplot(1, 2, 2)
plt.imshow(transformed_image, cmap='gray')
plt.title(f'Power-Law Transformed Image (Gamma={gamma})')
plt.axis('off')

plt.show()

"""Analyze the effect of gamma values on the image appearance, especially for values less than
and greater than 1
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Function to apply gamma correction
def gamma_correction(image, gamma):
    # Normalize the image to range [0, 1]
    image_normalized = image / 255.0
    # Apply gamma correction
    image_corrected = np.power(image_normalized, gamma)
    # Rescale back to [0, 255]
    image_corrected = np.uint8(image_corrected * 255)
    return image_corrected

# Read the image
image = cv2.imread('/content/einstein.jpg')

# Convert BGR to RGB for displaying with Matplotlib
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Different gamma values to test
gamma_values = [0.5, 1, 1.5, 2.0]

# Plot the original image and images with different gamma values
plt.figure(figsize=(12, 8))

# Original image
plt.subplot(2, 3, 1)
plt.imshow(image_rgb)
plt.title('Original Image')
plt.axis('off')

# Gamma corrected images
for i, gamma in enumerate(gamma_values):
    corrected_image = gamma_correction(image_rgb, gamma)
    plt.subplot(2, 3, i + 2)
    plt.imshow(corrected_image)
    plt.title(f'Gamma = {gamma}')
    plt.axis('off')

plt.tight_layout()
plt.show()

"""Experiment with different image types (e.g., medical, satellite, natural) to observe the impact
of transformations
"""

import numpy as np
import cv2
from PIL import Image
import matplotlib.pyplot as plt

# Function to apply power-law transformation
def powerlaw_transformation(image, gamma=1.0):
    # Normalize image to the range [0, 1]
    image = np.array(image, dtype=np.float32) / 255.0
    # Apply the power-law transformation
    transformed_image = np.power(image, gamma)
    # Convert back to range [0, 255] and uint8
    transformed_image = np.uint8(transformed_image * 255)
    return transformed_image

# Load sample images of different types
# Replace these paths with actual paths to your images
image_paths = [
    "/content/MRI_blackandwhite.png",   # e.g., X-ray or MRI image
    "/content/Greyscale-satellite-image-centred-on-SIRTAs-Laboratory-48713-N-2208-E_Q320.jpg",  # e.g., satellite imagery
    "/content/einstein.jpg"    # e.g., landscape or nature image
]

# Set gamma values to experiment with
gamma_values = [0.5, 1.0, 2.0]

# Plot original and transformed images for each type
fig, axes = plt.subplots(len(image_paths), len(gamma_values) + 1, figsize=(12, 6))
for i, image_path in enumerate(image_paths):
    # Load image using OpenCV or PIL
    image = Image.open(image_path)

    # Show original image
    axes[i][0].imshow(image)
    axes[i][0].set_title("Original")
    axes[i][0].axis('off')

    # Apply and display power-law transformations for each gamma value
    for j, gamma in enumerate(gamma_values):
        transformed_image = powerlaw_transformation(image, gamma)
        axes[i][j + 1].imshow(transformed_image, cmap='gray')
        axes[i][j + 1].set_title(f"Gamma = {gamma}")
        axes[i][j + 1].axis('off')

plt.tight_layout()
plt.show()

"""Spatial Filtering
1. Implement mean, median, and Gaussian filters. Apply them to images with different noise
types (salt-and-pepper, Gaussian) and compare the results.
2. Design a custom filter for sharpening edges while preserving image details. Apply it to a
natural image and evaluate its performance.
3. Experiment with different Laplacian operators (4-connected, 8-connected) and compare their
edge detection capabilities.
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Read the image
image = cv2.imread('/content/einstein.jpg', cv2.IMREAD_GRAYSCALE)

# Adding salt-and-pepper noise to the image
def add_salt_pepper_noise(image, salt_prob, pepper_prob):
    noisy_image = image.copy()
    total_pixels = image.size
    num_salt = int(total_pixels * salt_prob)
    num_pepper = int(total_pixels * pepper_prob)

    # Add salt (white) noise
    salt_coords = [np.random.randint(0, i-1, num_salt) for i in image.shape]
    noisy_image[salt_coords[0], salt_coords[1]] = 255

    # Add pepper (black) noise
    pepper_coords = [np.random.randint(0, i-1, num_pepper) for i in image.shape]
    noisy_image[pepper_coords[0], pepper_coords[1]] = 0

    return noisy_image

# Gaussian noise function
def add_gaussian_noise(image, mean=0, var=0.01):
    row, col = image.shape
    sigma = var**0.5
    gauss = np.random.normal(mean, sigma, (row, col))
    noisy = np.uint8(np.clip(image + gauss, 0, 255))
    return noisy

# Apply filters
mean_filtered = cv2.blur(image, (5, 5))
median_filtered = cv2.medianBlur(image, 5)
gaussian_filtered = cv2.GaussianBlur(image, (5, 5), 0)

# Show results
fig, axes = plt.subplots(1, 4, figsize=(20, 5))
axes[0].imshow(image, cmap='gray')
axes[0].set_title('Original Image')
axes[1].imshow(mean_filtered, cmap='gray')
axes[1].set_title('Mean Filter')
axes[2].imshow(median_filtered, cmap='gray')
axes[2].set_title('Median Filter')
axes[3].imshow(gaussian_filtered, cmap='gray')
axes[3].set_title('Gaussian Filter')
for ax in axes:
    ax.axis('off')
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Read the image
image = cv2.imread('/content/einstein.jpg', cv2.IMREAD_GRAYSCALE)

# Custom sharpening kernel
sharpening_kernel = np.array([[0, -1, 0],
                               [-1, 5,-1],
                               [0, -1, 0]])

# Apply the filter
sharpened_image = cv2.filter2D(image, -1, sharpening_kernel)

# Show results
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.imshow(image, cmap='gray')
plt.title('Original Image')
plt.axis('off')
plt.subplot(1, 2, 2)
plt.imshow(sharpened_image, cmap='gray')
plt.title('Sharpened Image')
plt.axis('off')
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Read the image
image = cv2.imread('/content/einstein.jpg', cv2.IMREAD_GRAYSCALE)

# Apply Laplacian filters with different connectivity
laplacian_4 = cv2.Laplacian(image, cv2.CV_64F, ksize=3, borderType=cv2.BORDER_DEFAULT)
laplacian_8 = cv2.filter2D(image, -1, np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]]))

# Show results
plt.figure(figsize=(10, 5))
plt.subplot(1, 3, 1)
plt.imshow(image, cmap='gray')
plt.title('Original Image')
plt.axis('off')
plt.subplot(1, 3, 2)
plt.imshow(laplacian_4, cmap='gray')
plt.title('Laplacian 4-connected')
plt.axis('off')
plt.subplot(1, 3, 3)
plt.imshow(laplacian_8, cmap='gray')
plt.title('Laplacian 8-connected')
plt.axis('off')
plt.show()

"""Image Enhancement: Arithmetic/Logic Operations
4. Implement image subtraction to detect changes between two images (e.g., before and after an
event).
5. Create a simple image watermarking system using image addition and subtraction.
6. Experiment with image averaging to reduce noise in a sequence of images.
"""



import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the images
image_before = cv2.imread('/content/star-1-300x168.jpg', cv2.IMREAD_GRAYSCALE)
image_after = cv2.imread('/content/dot-300x168.jpg', cv2.IMREAD_GRAYSCALE)

# Ensure both images are the same size
if image_before.shape != image_after.shape:
    print("Error: Images must have the same dimensions.")
    exit()

# Perform image subtraction
difference = cv2.absdiff(image_before, image_after)

plt.figure(figsize=(10, 5))

# Original images
plt.subplot(1, 3, 1)
plt.imshow(cv2.cvtColor(image_before, cv2.COLOR_BGR2RGB))
plt.title('Before Image')
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(cv2.cvtColor(image_after, cv2.COLOR_BGR2RGB))
plt.title('After Image')
plt.axis('off')

# Difference image
plt.subplot(1, 3, 3)
plt.imshow(difference, cmap='gray')
plt.title('Difference (Subtraction)')
plt.axis('off')

plt.show()
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the original image and the watermark image
image = cv2.imread('/content/1-500x250-3.jpg')
watermark = cv2.imread('/content/2-500x250-2.jpg', cv2.IMREAD_UNCHANGED)  # Assuming watermark has transparency

# Resize watermark to fit the original image (optional)
watermark_resized = cv2.resize(watermark, (image.shape[1], image.shape[0]))

# Convert watermark to 3 channels if it has an alpha channel (transparency)
if watermark_resized.shape[2] == 4:
    watermark_resized_rgb = cv2.cvtColor(watermark_resized, cv2.COLOR_BGRA2BGR)
else:
    watermark_resized_rgb = watermark_resized

# Add watermark to the original image (using simple addition)
watermarked_image = cv2.addWeighted(image, 1, watermark_resized_rgb, 0.5, 0)

# Display the original image, watermark, resized watermark, watermarked image, and image without watermark
plt.figure(figsize=(15, 10))

# Original image
plt.subplot(2, 3, 1)
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.title('Original Image')
plt.axis('off')

# Watermark image
plt.subplot(2, 3, 2)
plt.imshow(cv2.cvtColor(watermark_resized, cv2.COLOR_BGRA2RGBA))  # If watermark has transparency
plt.title('Watermark Image')
plt.axis('off')

# Resized watermark image
plt.subplot(2, 3, 3)
plt.imshow(cv2.cvtColor(watermark_resized_rgb, cv2.COLOR_BGR2RGB))
plt.title('Resized Watermark')
plt.axis('off')

# Watermarked image (image with watermark added)
plt.subplot(2, 3, 4)
plt.imshow(cv2.cvtColor(watermarked_image, cv2.COLOR_BGR2RGB))
plt.title('Watermarked Image')
plt.axis('off')

# Subtract the watermark to reveal the original image
image_without_watermark = cv2.subtract(watermarked_image, watermark_resized_rgb)

plt.subplot(2, 3, 5)
plt.imshow(cv2.cvtColor(image_without_watermark, cv2.COLOR_BGR2RGB))
plt.title('Image Without Watermark')
plt.axis('off')

plt.tight_layout()
plt.show()
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load a sequence of images
image1 = cv2.imread('/content/2-500x250-2.jpg')
image2 = cv2.imread('/content/1-500x250-3.jpg')
image3 = cv2.imread('/content/2-500x250-2.jpg')

# Convert images to grayscale (optional, depending on the application)
image1_gray = cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY)
image2_gray = cv2.cvtColor(image2, cv2.COLOR_BGR2GRAY)
image3_gray = cv2.cvtColor(image3, cv2.COLOR_BGR2GRAY)

# Stack images
images = np.stack([image1_gray, image2_gray, image3_gray], axis=0)

# Average the images to reduce noise
averaged_image = np.mean(images, axis=0).astype(np.uint8)

# Display the original images and the averaged image
plt.figure(figsize=(20, 10))

# Original images
plt.subplot(1, 4, 1)
plt.imshow(image1_gray, cmap='gray')
plt.title('Image 1')
plt.axis('off')

plt.subplot(1, 4, 2)
plt.imshow(image2_gray, cmap='gray')
plt.title('Image 2')
plt.axis('off')

plt.subplot(1, 4, 3)
plt.imshow(image3_gray, cmap='gray')
plt.title('Image 3')
plt.axis('off')

# Averaged image
plt.subplot(1, 4, 4)
plt.imshow(averaged_image, cmap='gray')
plt.title('Averaged Image')
plt.axis('off')

plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load a sequence of images
image1 = cv2.imread('/content/2-500x250-2.jpg')
image2 = cv2.imread('/content/1-500x250-3.jpg')
image3 = cv2.imread('/content/2-500x250-2.jpg')

# Convert images to grayscale (optional, depending on the application)
image1_gray = cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY)
image2_gray = cv2.cvtColor(image2, cv2.COLOR_BGR2GRAY)
image3_gray = cv2.cvtColor(image3, cv2.COLOR_BGR2GRAY)

# Stack images
images = np.stack([image1_gray, image2_gray, image3_gray], axis=0)

# Average the images to reduce noise
averaged_image = np.mean(images, axis=0).astype(np.uint8)

# Display the original images and the averaged image
plt.figure(figsize=(20, 10))

# Original images
plt.subplot(1, 4, 1)
plt.imshow(image1_gray, cmap='gray')
plt.title('Image 1')
plt.axis('off')

plt.subplot(1, 4, 2)
plt.imshow(image2_gray, cmap='gray')
plt.title('Image 2')
plt.axis('off')

plt.subplot(1, 4, 3)
plt.imshow(image3_gray, cmap='gray')
plt.title('Image 3')
plt.axis('off')

# Averaged image
plt.subplot(1, 4, 4)
plt.imshow(averaged_image, cmap='gray')
plt.title('Averaged Image')
plt.axis('off')

plt.show()

"""Perform Discrete Fourier Transform, Z- transform KL Transform on a gray scale image."""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import eigh

# Load a grayscale image
def load_grayscale_image(image_path):
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if image is None:
        raise ValueError("Image not found or unable to read.")
    return image

# 1. Discrete Fourier Transform (DFT)
def perform_dft(image):
    dft = np.fft.fft2(image)
    dft_shift = np.fft.fftshift(dft)  # Shift the zero frequency to the center
    magnitude_spectrum = 20 * np.log(np.abs(dft_shift) + 1)
    return magnitude_spectrum

# 2. Z-Transform (Single-row example)
def perform_z_transform(image, row=0):
    if row >= image.shape[0]:
        raise ValueError("Row index exceeds image dimensions.")
    row_data = image[row, :]
    z_transformed = np.fft.fft(row_data)  # Z-transform is equivalent to Fourier Transform on discrete signals
    magnitude = np.abs(z_transformed)
    return magnitude

# 3. Karhunen-Loève Transform (KL Transform)
def perform_kl_transform(image):
    # Flatten the image into a 2D array (rows as observations)
    image_flatten = image.reshape(-1, image.shape[1])
    covariance_matrix = np.cov(image_flatten, rowvar=False)

    # Compute eigenvalues and eigenvectors
    eigenvalues, eigenvectors = eigh(covariance_matrix)

    # Sort eigenvalues and eigenvectors in descending order
    idx = np.argsort(eigenvalues)[::-1]
    eigenvalues = eigenvalues[idx]
    eigenvectors = eigenvectors[:, idx]

    # Transform the image data
    transformed_data = np.dot(image_flatten, eigenvectors)
    transformed_image = transformed_data.reshape(image.shape)
    return transformed_image

# Main script to test the transforms
def main():
    image_path = "/content/56368408-58561980-61c5-11e9-9800-0678dc02b4e7.png"  # Replace with your image path
    image = load_grayscale_image(image_path)

    # Perform DFT
    dft_result = perform_dft(image)

    # Perform Z-Transform on the first row
    z_transform_result = perform_z_transform(image, row=0)

    # Perform KL Transform
    kl_transform_result = perform_kl_transform(image)

    # Plot results
    plt.figure(figsize=(12, 8))

    # Original Image
    plt.subplot(2, 2, 1)
    plt.title("Original Image")
    plt.imshow(image, cmap='gray')

    # DFT Result
    plt.subplot(2, 2, 2)
    plt.title("DFT Magnitude Spectrum")
    plt.imshow(dft_result, cmap='gray')

    # Z-Transform Magnitude (Plotted as a graph)
    plt.subplot(2, 2, 3)
    plt.title("Z-Transform (Row 0)")
    plt.plot(z_transform_result)

    # KL Transform Result
    plt.subplot(2, 2, 4)
    plt.title("KL Transform Result")
    plt.imshow(kl_transform_result, cmap='gray')

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()

"""Implement histogram equalization and matching on a grayscale image. Compare the results
visually and quantitatively using metrics like entropy
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import eigh
from skimage.exposure import match_histograms
from scipy.stats import entropy

# Load a grayscale image
def load_grayscale_image(image_path):
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if image is None:
        raise ValueError("Image not found or unable to read.")
    return image

# 1. Discrete Fourier Transform (DFT)
def perform_dft(image):
    dft = np.fft.fft2(image)
    dft_shift = np.fft.fftshift(dft)  # Shift the zero frequency to the center
    magnitude_spectrum = 20 * np.log(np.abs(dft_shift) + 1)
    return magnitude_spectrum

# 2. Z-Transform (Single-row example)
def perform_z_transform(image, row=0):
    if row >= image.shape[0]:
        raise ValueError("Row index exceeds image dimensions.")
    row_data = image[row, :]
    z_transformed = np.fft.fft(row_data)  # Z-transform is equivalent to Fourier Transform on discrete signals
    magnitude = np.abs(z_transformed)
    return magnitude

# 3. Karhunen-Loève Transform (KL Transform)
def perform_kl_transform(image):
    # Flatten the image into a 2D array (rows as observations)
    image_flatten = image.reshape(-1, image.shape[1])
    covariance_matrix = np.cov(image_flatten, rowvar=False)

    # Compute eigenvalues and eigenvectors
    eigenvalues, eigenvectors = eigh(covariance_matrix)

    # Sort eigenvalues and eigenvectors in descending order
    idx = np.argsort(eigenvalues)[::-1]
    eigenvalues = eigenvalues[idx]
    eigenvectors = eigenvectors[:, idx]

    # Transform the image data
    transformed_data = np.dot(image_flatten, eigenvectors)
    transformed_image = transformed_data.reshape(image.shape)
    return transformed_image

# 4. Histogram Equalization
def perform_histogram_equalization(image):
    equalized_image = cv2.equalizeHist(image)
    return equalized_image
# 5. Histogram Matching
def perform_histogram_matching(image, reference_image):
    matched_image = match_histograms(image, reference_image, channel_axis=None)  # Use channel_axis instead of multichannel
    return matched_image



# Calculate Entropy
def calculate_entropy(image):
    histogram, _ = np.histogram(image.flatten(), bins=256, range=(0, 256), density=True)
    return entropy(histogram)

# Main script to test the transforms
def main():
    image_path = "/content/einstein.jpg"  # Replace with your image path
    reference_image_path = "/content/images (2).jpeg"  # Replace with your reference image path

    # Load images
    image = load_grayscale_image(image_path)
    reference_image = load_grayscale_image(reference_image_path)

    # Perform DFT
    dft_result = perform_dft(image)

    # Perform Z-Transform on the first row
    z_transform_result = perform_z_transform(image, row=0)

    # Perform KL Transform
    kl_transform_result = perform_kl_transform(image)

    # Perform Histogram Equalization
    equalized_image = perform_histogram_equalization(image)

    # Perform Histogram Matching
    matched_image = perform_histogram_matching(image, reference_image)

    # Calculate Entropy
    original_entropy = calculate_entropy(image)
    equalized_entropy = calculate_entropy(equalized_image)
    matched_entropy = calculate_entropy(matched_image)

    # Print Entropies
    print(f"Original Image Entropy: {original_entropy:.4f}")
    print(f"Equalized Image Entropy: {equalized_entropy:.4f}")
    print(f"Matched Image Entropy: {matched_entropy:.4f}")

    # Plot results
    plt.figure(figsize=(12, 8))

    # Original Image
    plt.subplot(2, 3, 1)
    plt.title("Original Image")
    plt.imshow(image, cmap='gray')

    # DFT Result
    plt.subplot(2, 3, 2)
    plt.title("DFT Magnitude Spectrum")
    plt.imshow(dft_result, cmap='gray')

    # Equalized Image
    plt.subplot(2, 3, 3)
    plt.title("Histogram Equalized")
    plt.imshow(equalized_image, cmap='gray')

    # Matched Image
    plt.subplot(2, 3, 4)
    plt.title("Histogram Matched")
    plt.imshow(matched_image, cmap='gray')

    # KL Transform Result
    plt.subplot(2, 3, 5)
    plt.title("KL Transform Result")
    plt.imshow(kl_transform_result, cmap='gray')

    # Z-Transform Magnitude (Plotted as a graph)
    plt.subplot(2, 3, 6)
    plt.title("Z-Transform (Row 0)")
    plt.plot(z_transform_result)

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()

"""Design a contrast enhancement technique for images with low contrast. Apply it to a real-
world image and evaluate its effectiveness.
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from skimage.exposure import match_histograms

# Load a grayscale image
def load_grayscale_image(image_path):
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if image is None:
        raise ValueError("Image not found or unable to read.")
    return image

# Contrast Enhancement using CLAHE and Gamma Correction
def contrast_enhancement(image, clip_limit=2.0, tile_grid_size=(8, 8), gamma=1.2):
    # 1. Apply CLAHE (Contrast Limited Adaptive Histogram Equalization)
    clahe = cv2.createCLAHE(clipLimit=clip_limit, tileGridSize=tile_grid_size)
    enhanced_image = clahe.apply(image)

    # 2. Apply Gamma Correction
    gamma_corrected = np.power(enhanced_image / 255.0, gamma) * 255
    gamma_corrected = np.clip(gamma_corrected, 0, 255).astype(np.uint8)

    return gamma_corrected

# Evaluate contrast enhancement using CNR (Contrast-to-Noise Ratio)
def compute_cnr(original, enhanced):
    original_mean = np.mean(original)
    enhanced_mean = np.mean(enhanced)

    original_std = np.std(original)
    enhanced_std = np.std(enhanced)

    cnr_original = original_mean / original_std if original_std != 0 else 0
    cnr_enhanced = enhanced_mean / enhanced_std if enhanced_std != 0 else 0

    return cnr_original, cnr_enhanced

# Main script to test the contrast enhancement
def main():
    image_path = "/content/images (3).jpeg"  # Replace with your image path
    image = load_grayscale_image(image_path)

    # Apply Contrast Enhancement
    enhanced_image = contrast_enhancement(image, clip_limit=2.0, tile_grid_size=(8, 8), gamma=1.2)

    # Evaluate Effectiveness
    cnr_original, cnr_enhanced = compute_cnr(image, enhanced_image)

    print(f"CNR (Original): {cnr_original:.4f}")
    print(f"CNR (Enhanced): {cnr_enhanced:.4f}")

    # Plot results
    plt.figure(figsize=(12, 6))

    # Original Image
    plt.subplot(1, 2, 1)
    plt.title("Original Image")
    plt.imshow(image, cmap='gray')
    plt.axis('off')

    # Enhanced Image
    plt.subplot(1, 2, 2)
    plt.title("Enhanced Image")
    plt.imshow(enhanced_image, cmap='gray')
    plt.axis('off')

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()

import cv2
import numpy as np
import matplotlib.pyplot as plt
from skimage.exposure import match_histograms

# Load a grayscale image
def load_grayscale_image(image_path):
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if image is None:
        raise ValueError("Image not found or unable to read.")
    return image

# Contrast Enhancement using CLAHE and Gamma Correction
def contrast_enhancement(image, clip_limit=2.0, tile_grid_size=(8, 8), gamma=1.2):
    # 1. Apply CLAHE (Contrast Limited Adaptive Histogram Equalization)
    clahe = cv2.createCLAHE(clipLimit=clip_limit, tileGridSize=tile_grid_size)
    enhanced_image = clahe.apply(image)

    # 2. Apply Gamma Correction
    gamma_corrected = np.power(enhanced_image / 255.0, gamma) * 255
    gamma_corrected = np.clip(gamma_corrected, 0, 255).astype(np.uint8)

    return gamma_corrected

# Evaluate contrast enhancement using CNR (Contrast-to-Noise Ratio)
def compute_cnr(original, enhanced):
    original_mean = np.mean(original)
    enhanced_mean = np.mean(enhanced)

    original_std = np.std(original)
    enhanced_std = np.std(enhanced)

    cnr_original = original_mean / original_std if original_std != 0 else 0
    cnr_enhanced = enhanced_mean / enhanced_std if enhanced_std != 0 else 0

    return cnr_original, cnr_enhanced

# Main script to test the contrast enhancement
def main():
    image_path = "/content/qKZBg.png"  # Replace with your image path
    image = load_grayscale_image(image_path)

    # Apply Contrast Enhancement
    enhanced_image = contrast_enhancement(image, clip_limit=2.0, tile_grid_size=(8, 8), gamma=1.2)

    # Evaluate Effectiveness
    cnr_original, cnr_enhanced = compute_cnr(image, enhanced_image)

    print(f"CNR (Original): {cnr_original:.4f}")
    print(f"CNR (Enhanced): {cnr_enhanced:.4f}")

    # Plot results
    plt.figure(figsize=(12, 6))

    # Original Image
    plt.subplot(1, 2, 1)
    plt.title("Original Image")
    plt.imshow(image, cmap='gray')
    plt.axis('off')

    # Enhanced Image
    plt.subplot(1, 2, 2)
    plt.title("Enhanced Image")
    plt.imshow(enhanced_image, cmap='gray')
    plt.axis('off')

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()
123456